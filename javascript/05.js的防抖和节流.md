# JS的防抖和节流

-

## 防抖函数

- 当持续触发事件，一定时间内没有在触发时间，事件处理函数才执行一次；如果设定的时间到来之前，又一次触发了时间，就重新开始延时

### 防抖示例

```html
<html DOCTYPE!>
    <body>
        <input id="input"/>
    </body>	
</html>
<script>
var input = document.getElementById("input");
function debounce(delay,callback){
    let timer;
    return function(value){
        clearTimeout(timer)
        /*
        	想清除的是setTimeout 我们应该存储这个timer的变量
        	timer变量需要一直保存在内存中
        	既然不想打印之前已经输入的结果，清除之前解除的定时器
        	应该存储这个timer的变量
        	一直要在内存中（闭包）
        */
        timer = setTimeout(function(){
            console.log(value);
            callback(value)
        },delay)
    }
}
function fn(value){
    console.log(value)
}
/*我需要的是 首先 输入的结果是出现一次 是在我键盘不在输入后1秒*/
var debounceFunc = debounce(1000);
input.addEventListener('keyup',function(e){
    debounceFunc(e.target.value)
})
</script>
```

### 应用场景

输入搜索：输入接触后n秒才进行搜索请求，n秒内又输入的内容，就重新计时

